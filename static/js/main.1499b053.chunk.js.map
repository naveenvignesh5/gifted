{"version":3,"sources":["libs/withNetwork.js","redux/actionTypes.js","constants.js","redux/reducers/gif.js","redux/reducers/index.js","redux/store.js","redux/actions/action-gif.js","components/SearchBar/index.js","components/SearchBar/SearchBar.js","components/GifList/GifView.js","components/GifList/index.js","components/GifList/GifList.js","components/PaginationTab/PaginationTab.js","components/PaginationTab/index.js","components/Navbar/Navbar.js","components/Tag/Tag.js","components/ToggleSwitch/index.js","components/ToggleSwitch/ToggleSwitch.js","libs/local_storage.js","libs/search_entry.js","pages/home/home.js","pages/home/index.js","app.js","serviceWorker.js","index.js"],"names":["ComposedComponent","ACTION_TYPES","keymirror","REQUEST_FETCH_GIFS","REQUEST_FETCH_GIFS_SUCCESS","REQUEST_FETCH_GIFS_FAILURE","REQUEST_PLAY","REQUEST_PAUSE","GIF_COUNT_PER_PAGE","DEFAULT_GIF_SEARCH_QUERY","initialState","isFetching","isError","gifs","totalPages","error","isPlaying","rootReducer","combineReducers","gif","state","action","type","Object","assign","payload","data","pagination","total_count","store","createStore","applyMiddleware","thunk","requestGifFailure","fetchGifs","searchObj","dispatch","a","queryString","keys","map","key","join","axios","get","process","res","togglePlay","play","requestPlayToggle","SearchBar","this","props","onSearchPress","inputProps","className","onClick","PureComponent","GifView","memo","src","staticSrc","useState","imageLoaded","updateImageLoaded","dynamicImageLoaded","updateDynamicImageLoaded","useSelector","onLoad","alt","GifList","index","toString","images","downsized_still","url","downsized","isMobile","window","innerWidth","PaginationTab","currentPage","pageLimit","onPagePress","onPrevButtonPress","onNextButtonPress","startPage","updateStartPage","newStartPage","buttons","limit","i","push","renderPageButtons","Navbar","brandName","children","isDarkTheme","Tag","text","onTagPress","isActive","ToggleSwitch","getItem","item","localStorage","JSON","parse","setItem","obj","itemString","stringify","updateSearchEntry","newEntry","entries","length","pop","unshift","getSearchEntry","Home","query","darkThemeEnabled","search_entries","setState","updatePage","offset","q","handleOnQueryChange","e","target","value","handleFetchGifs","query_default","final_query","prevState","handleOnKeyPress","handleThemeToggle","handlePlayToggle","renderGifs","fetchingGifs","fetchingGifsError","renderSearchEntries","entry","t","gifPlaying","onChange","checked","ref","r","searchBarDom","onKeyPress","placeholder","Component","home","connect","bindActionCreators","withNetwork","Store","isDisconnected","handleConnectionChange","navigator","onLine","webPing","setInterval","fetch","mode","then","clearInterval","catch","addEventListener","removeEventListener","Boolean","location","hostname","match","ReactDOM","render","document","getElementById","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.1499b053.chunk.js","sourcesContent":["import React, { Component } from \"react\";\n\nexport default ComposedComponent => {\n  class NetworkDetector extends Component {\n    state = {\n      isDisconnected: false\n    };\n\n    componentDidMount() {\n      this.handleConnectionChange();\n      window.addEventListener(\"online\", this.handleConnectionChange);\n      window.addEventListener(\"offline\", this.handleConnectionChange);\n    }\n\n    componentWillUnmount() {\n      window.removeEventListener(\"online\", this.handleConnectionChange);\n      window.removeEventListener(\"offline\", this.handleConnectionChange);\n    }\n\n    handleConnectionChange = () => {\n      if (navigator.onLine) {\n        const webPing = setInterval(() => {\n          fetch(\"//google.com\", {\n            mode: \"no-cors\"\n          })\n            .then(() => {\n              this.setState({ isDisconnected: false }, () => {\n                return clearInterval(webPing);\n              });\n            })\n            .catch(() => this.setState({ isDisconnected: true }));\n        }, 2000);\n        return;\n      }\n\n      this.setState({ isDisconnected: true });\n    };\n\n    render() {\n      const { isDisconnected } = this.state;\n\n      return (\n        <>\n          {isDisconnected && (\n            <div className=\"internet-error\">\n              <p className=\"title\">No network</p>\n              <p className=\"subtitle\">Please connect to internet and refresh.</p>\n            </div>\n          )}\n          {!isDisconnected && <ComposedComponent {...this.props} />}\n        </>\n      );\n    }\n  }\n\n  return NetworkDetector;\n};\n","import keymirror from 'keymirror';\n\nconst ACTION_TYPES = keymirror({\n    REQUEST_FETCH_GIFS: null,\n    REQUEST_FETCH_GIFS_SUCCESS: null,\n    REQUEST_FETCH_GIFS_FAILURE: null,\n\n    REQUEST_PLAY: null,\n    REQUEST_PAUSE: null,\n});\n\nexport { ACTION_TYPES };\n","export const GIF_COUNT_PER_PAGE = 24;\nexport const DEFAULT_PAGE_COUNT_PER_GROUP = 6;\nexport const DEFAULT_GIF_SEARCH_QUERY = 'cats';\n\nexport const API_ENDPOINT = '//api.giphy.com/v1';\n\nexport const SEARCH_ENTRY_STORAGE_KEY = 'gojek_gifted_search';\nexport const SEARCH_ENTRY_LIMIT = 5;","import { ACTION_TYPES } from \"../actionTypes\";\nimport { GIF_COUNT_PER_PAGE } from \"../../constants\";\n\nconst initialState = {\n  isFetching: false,\n  isError: false,\n  gifs: [],\n  totalPages: 0,\n  error: null,\n  isPlaying: false,\n};\n\nexport default (state = initialState, action) => {\n  switch (action.type) {\n    case ACTION_TYPES.REQUEST_FETCH_GIFS:\n      return Object.assign({}, initialState, state, { isFetching: true });\n    case ACTION_TYPES.REQUEST_FETCH_GIFS_SUCCESS:\n      return Object.assign({}, initialState, state, { gifs: action.payload.data, totalPages: action.payload.pagination.total_count / GIF_COUNT_PER_PAGE });\n    case ACTION_TYPES.REQUEST_FETCH_GIFS_FAILURE:\n      return Object.assign({}, initialState, state, { isError: true, error: action.error });\n    case ACTION_TYPES.REQUEST_PLAY:\n      return Object.assign({}, initialState, state, { isPlaying: true });\n    case ACTION_TYPES.REQUEST_PAUSE:\n      return Object.assign({}, initialState, state, { isPlaying: false });\n    default:\n      return state;\n  }\n};\n","import { combineReducers } from 'redux';\n\n// reducers\nimport gif from './gif';\n\nconst rootReducer = combineReducers({\n    gif,\n});\n\nexport default rootReducer;\n","import { createStore, applyMiddleware } from 'redux';\nimport thunk from 'redux-thunk';\n\nimport rootReducer from './reducers';\n\nconst store = createStore(\n    rootReducer,\n    applyMiddleware(thunk),\n);\n\nexport default store;\n","import axios from \"axios\";\n\nimport { ACTION_TYPES } from \"../actionTypes\";\nimport { GIF_COUNT_PER_PAGE, API_ENDPOINT } from \"../../constants\";\n\nconst requestGif = () => ({\n  type: ACTION_TYPES.REQUEST_FETCH_GIFS\n});\n\nconst requestGifSuccess = payload => ({\n  type: ACTION_TYPES.REQUEST_FETCH_GIFS_SUCCESS,\n  payload\n});\n\nconst requestGifFailure = error => ({\n  type: ACTION_TYPES.REQUEST_FETCH_GIFS_FAILURE,\n  error\n});\n\nconst requestPlayToggle = (play = false) => ({\n  type: play ? ACTION_TYPES.REQUEST_PLAY : ACTION_TYPES.REQUEST_PAUSE\n});\n\nconst fetchGifs = searchObj => async dispatch => {\n  try {\n    dispatch(requestGif());\n    const queryString = Object.keys(searchObj)\n      .map(key => key + \"=\" + searchObj[key])\n      .join(\"&\");\n    const res = await axios.get(\n      `${API_ENDPOINT}/gifs/search?api_key=${process.env.REACT_APP_GIPHY_KEY}&${queryString}&limit=${GIF_COUNT_PER_PAGE}`\n    ); // eslint-disable-line\n    if (res.data) {\n      dispatch(requestGifSuccess(res.data));\n      return;\n    }\n    dispatch(requestGifFailure(\"no-data-found\"));\n  } catch (err) {\n    dispatch(requestGifFailure(err));\n  }\n};\n\nconst togglePlay = play => dispatch => {\n    dispatch(requestPlayToggle(play));\n};\n\nexport { fetchGifs, requestGif, togglePlay };\n","import SearchBar from './SearchBar';\n\nexport default SearchBar;\n","import React, { PureComponent } from \"react\";\n\nimport './SearchBar.sass';\n\nclass SearchBar extends PureComponent {\n  state = {};\n  \n  render() {\n    const { onSearchPress, ...inputProps } = this.props;\n    return (\n      <div className=\"search-bar-wrapper\">\n        <input className=\"search-bar-input\" {...inputProps} />\n        <button className=\"search-button\" onClick={onSearchPress}>Search</button>\n      </div>\n    );\n  }\n}\n\nexport default SearchBar;\n","import React, { memo, useState } from \"react\";\nimport { useSelector } from 'react-redux';\n\nimport \"./Gif.sass\";\n\nconst GifView = memo(({ src, staticSrc }) => {\n  const [imageLoaded, updateImageLoaded] = useState(false);\n  const [dynamicImageLoaded, updateDynamicImageLoaded] = useState(false);\n  \n  const isPlaying = useSelector(state => state.gif.isPlaying);\n\n  return (\n    <div className={`gif-image-wrapper ${isPlaying ? 'is-active' : ''}`}>\n      {(!imageLoaded || !dynamicImageLoaded) && (\n        <div\n          className=\"gif-loading\"\n        >\n          Loading GIF...\n        </div>\n      )}\n      <img\n        className=\"gif-image static\"\n        onLoad={() => {\n          updateImageLoaded(true);\n        }}\n        src={staticSrc}\n        alt=\"animated\"\n      />\n      <img\n        className=\"gif-image dynamic\"\n        onLoad={() => {\n          updateDynamicImageLoaded(true);\n        }}\n        src={src}\n        alt=\"animated\"\n      />\n    </div>\n  );\n});\n\nexport default GifView;\n","import GifList from './GifList';\n\nexport default GifList;\n","import React, { memo } from \"react\";\nimport GifView from \"./GifView\";\n\nimport \"./Gif.sass\";\n\nconst GifList = memo(({ gifs = [] }) => {\n  return (\n    <div className=\"gif-list\">\n      <div className=\"gif-wrapper\">\n        {gifs.map((gif, index) => (\n          <GifView key={index.toString()} staticSrc={gif.images.downsized_still.url} src={gif.images.downsized.url} />\n        ))}\n      </div>\n    </div>\n  );\n});\n\nexport default GifList;\n","import React, { memo, useState } from \"react\";\n\nimport \"./PaginationTab.sass\";\nimport { DEFAULT_PAGE_COUNT_PER_GROUP } from \"../../constants\";\n\nconst isMobile = window.innerWidth < 798 ? true : false;\n\nconst PaginationTab = memo(\n  ({\n    totalPages,\n    currentPage,\n    pageLimit = isMobile ? 3 : DEFAULT_PAGE_COUNT_PER_GROUP,\n    onPagePress,\n    onPrevButtonPress,\n    onNextButtonPress\n  }) => {\n    const [startPage, updateStartPage] = useState(1);\n\n    const onPrevPress = () => {\n      if (startPage === 1) return;\n\n      const newStartPage = startPage - pageLimit;\n\n      if (newStartPage > 0) {\n        updateStartPage(newStartPage);\n        onPrevButtonPress(newStartPage);\n      }\n    };\n\n    const onNextPress = () => {\n      if (startPage === totalPages) return;\n\n      const newStartPage = startPage + pageLimit;\n\n      if (newStartPage <= totalPages) {\n        updateStartPage(newStartPage);\n        onNextButtonPress(newStartPage);\n      }\n    };\n\n    const renderPageButtons = () => {\n      let buttons = [];\n\n      let limit = startPage + pageLimit - 1;\n\n      for (let i = startPage; i <= limit; i += 1) {\n        buttons.push(\n          <button\n            key={`page_${i}`}\n            onClick={() => onPagePress(i)}\n            className={`page-button ${currentPage === i ? \"is-active\" : \"\"}`}\n          >\n            {i}\n          </button>\n        );\n      }\n\n      return buttons;\n    };\n\n    return (\n      <div className=\"paginatin-tab\">\n        <div className=\"page-buttons-wrapper\">\n          <button className=\"page-button\" onClick={onPrevPress}>\n            {isMobile ? '<' : 'Prev'}\n          </button>\n          {renderPageButtons()}\n          <button className=\"page-button\" onClick={onNextPress}>\n          {isMobile ? '>' : 'Next'}\n          </button>\n        </div>\n      </div>\n      // <div className=\"is-hidden-mobile\">\n      // </div>\n    );\n  }\n);\n\nexport default PaginationTab;\n","import PaginationTab from './PaginationTab';\n\nexport default PaginationTab;\n","import React from \"react\";\n\n// styles\nimport \"./Navbar.sass\";\n\nconst Navbar = ({ brandName, isDarkTheme, children }) => (\n  <nav className=\"navbar\">\n    <p className=\"navbar-brand-name\">{brandName}</p>\n    <div className=\"navbar-toggle\">\n      {children}\n    </div>\n  </nav>\n);\n\nexport default Navbar;\n","import React from \"react\";\n\n// import { useSelector, useDispatch } from 'react-redux';\n\nimport \"./Tag.sass\";\n\nconst Tag = ({ text, onTagPress, isActive = false }) => {\n  return (\n    <button\n      className={`tag ${isActive ? \"is-active\" : \"\"}`}\n      onClick={() => {\n        onTagPress(text);\n      }}\n      // href=\"javascript:void(0);\"\n    >\n      {text}\n    </button>\n  );\n};\n\nexport default Tag;\n","import ToggleSwitch from './ToggleSwitch';\n\nexport default ToggleSwitch;\n","import React from 'react';\n\nimport './ToggleSwitch.sass';\n\nconst ToggleSwitch = (props) => (\n    <label className=\"switch\">\n        <input {...props} type=\"checkbox\"/>\n        <span className=\"slider round\"/>\n    </label>\n);\n\nexport default ToggleSwitch;\n","const getItem = (key) => {\n    let item = localStorage.getItem(key);\n    return JSON.parse(item);\n}\n\nconst setItem = (key, obj) => {\n    let itemString = JSON.stringify(obj);\n    localStorage.setItem(key, itemString);\n}\n\nexport { getItem, setItem }\n","import { getItem, setItem } from \"./local_storage\";\nimport { SEARCH_ENTRY_STORAGE_KEY, SEARCH_ENTRY_LIMIT } from \"../constants\";\n\n\nconst updateSearchEntry = (newEntry) => {\n    let entries = getItem(SEARCH_ENTRY_STORAGE_KEY);\n    \n    if (!entries) {\n        entries = [ newEntry ];\n        setItem(SEARCH_ENTRY_STORAGE_KEY, entries);\n        return;\n    }\n\n    if (entries.length >= SEARCH_ENTRY_LIMIT) entries.pop();\n\n    entries.unshift(newEntry);\n\n    setItem(SEARCH_ENTRY_STORAGE_KEY, entries);\n};\n\nconst getSearchEntry = () => {\n    let entries = getItem(SEARCH_ENTRY_STORAGE_KEY);\n\n    return entries;\n}\n\nexport  { updateSearchEntry, getSearchEntry };\n","import React, { Component } from \"react\";\nimport { connect } from \"react-redux\";\nimport { bindActionCreators } from \"redux\";\n\nimport { fetchGifs, togglePlay } from \"../../redux/actions/action-gif\";\n\n// components\nimport SearchBar from \"../../components/SearchBar\";\nimport GifList from \"../../components/GifList\";\nimport PaginationTab from \"../../components/PaginationTab\";\nimport Navbar from \"../../components/Navbar/Navbar\";\nimport { Tag } from \"../../components/Tag\";\nimport ToggleSwitch from \"../../components/ToggleSwitch\";\n\n// styles\nimport \"./home.sass\";\n\n// constants\nimport { GIF_COUNT_PER_PAGE, DEFAULT_GIF_SEARCH_QUERY } from \"../../constants\";\nimport { updateSearchEntry, getSearchEntry } from \"../../libs/search_entry\";\n\nclass Home extends Component {\n  state = {\n    currentPage: 1,\n    query: DEFAULT_GIF_SEARCH_QUERY,\n    darkThemeEnabled: false,\n    search_entries: []\n  };\n\n  componentDidMount() {\n    this.props.fetchGifs({ q: DEFAULT_GIF_SEARCH_QUERY });\n\n    this.updateSearchEntry();\n  }\n\n  updateSearchEntry = () => {\n    let search_entries = getSearchEntry();\n\n    this.setState({\n      search_entries\n    });\n  };\n\n  updatePage = currentPage => {\n    const offset = (currentPage - 1) * GIF_COUNT_PER_PAGE + 1;\n    this.setState({ currentPage }, () => {\n      this.props.fetchGifs({\n        q: this.state.query,\n        offset\n      });\n    });\n  };\n\n  handleOnQueryChange = e => {\n    this.setState({\n      query: e.target.value\n    });\n  };\n\n  handleFetchGifs = (offset = 1, query_default = \"\") => {\n    const { query = \"\" } = this.state;\n\n    let final_query = query_default || query;\n\n    updateSearchEntry(final_query); // updates local storage\n\n    let search_entries = getSearchEntry();\n\n    if (final_query && offset) {\n      this.setState(\n        prevState => {\n          return {\n            query: final_query,\n            search_entries,\n          };\n        },\n        () => {\n          this.props.fetchGifs({ q: final_query, offset });\n        }\n      );\n    }\n  };\n\n  handleOnKeyPress = e => {\n    if (e.key === \"Enter\") {\n      this.handleFetchGifs();\n    }\n  };\n\n  handleThemeToggle = darkThemeEnabled => {\n    this.setState({ darkThemeEnabled });\n  };\n\n  handlePlayToggle = isPlaying => {\n    this.props.togglePlay(isPlaying);\n  };\n\n  renderGifs = () => {\n    const { gifs, fetchingGifs, fetchingGifsError } = this.props;\n\n    if (gifs && gifs.length > 0) return <GifList gifs={gifs} />;\n\n    if (fetchingGifs || fetchingGifsError) {\n      return (\n        <div className=\"gif-status-section\">\n          {fetchingGifs && <p className=\"status-text\">Loading...</p>}\n          {fetchingGifsError && (\n            <p className=\"status-text\">Unable to load gifs.</p>\n          )}\n        </div>\n      );\n    }\n\n    return (\n      <div className=\"gif-status-section\">\n        <p className=\"status-text\">No Gifs Found.</p>;\n      </div>\n    );\n  };\n\n  renderSearchEntries = () => {\n    let { search_entries = [] } = this.state;\n\n    if (!search_entries || search_entries.length === 0) {\n      return null;\n    }\n\n    return (\n      <div className=\"tags-wrapper\">\n        {search_entries.map((entry, i) => (\n          <Tag\n            key={`tag_${i}`}\n            onTagPress={t => this.handleFetchGifs(1, t)}\n            text={entry}\n          />\n        ))}\n      </div>\n    );\n  };\n\n  render() {\n    const { currentPage, darkThemeEnabled, query } = this.state;\n    return (\n      <div className={`container theme-${darkThemeEnabled ? \"dark\" : \"light\"}`}>\n        <Navbar brandName=\"GIFted\">\n          <div className=\"label\">\n            {this.props.gifPlaying ? \"Pause\" : \"Play\"}\n          </div>\n          <ToggleSwitch\n            onChange={e => this.handlePlayToggle(e.target.checked)}\n          />\n          &nbsp;&nbsp;\n          <div className=\"label\">\n            {darkThemeEnabled ? \"Dark Theme\" : \"Light Theme\"}\n          </div>\n          <ToggleSwitch\n            onChange={e => this.handleThemeToggle(e.target.checked)}\n          />\n        </Navbar>\n        <SearchBar\n          ref={r => (this.searchBarDom = r)}\n          onSearchPress={() => this.handleFetchGifs()}\n          onChange={this.handleOnQueryChange}\n          value={query}\n          onKeyPress={this.handleOnKeyPress}\n          placeholder=\"Search a gif...\"\n        />\n        {this.renderSearchEntries()}\n        <PaginationTab\n          totalPages={this.props.totalPages}\n          onPrevButtonPress={this.updatePage}\n          onNextButtonPress={this.updatePage}\n          onPagePress={this.updatePage}\n          currentPage={currentPage}\n        />\n        {this.renderGifs()}\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = state => ({\n  gifs: state.gif.gifs,\n  fetchingGifs: state.gif.isFetching,\n  fetchingGifsError: state.gif.isError ? state.gif.error : null,\n  totalPages: state.gif.totalPages,\n  gifPlaying: state.gif.isPlaying\n});\n\nconst mapDispatchToProps = dispatch =>\n  bindActionCreators({ fetchGifs, togglePlay }, dispatch);\n\nexport default connect(mapStateToProps, mapDispatchToProps)(Home);\n","import home from './home'\n\nexport default home;\n","import React from \"react\";\nimport { Provider } from \"react-redux\";\n\nimport Store from './redux/store';\n\nimport withNetwork from './libs/withNetwork';\n\n// home page\nimport Home from \"./pages/home\";\n\n// styles\nimport './styles/app.sass';\n\nconst App = () => {\n  return (\n    <Provider store={Store}>\n      <Home />\n    </Provider>\n  );\n};\n\nexport default withNetwork(App);\n\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './styles/index.sass';\nimport App from './app';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}